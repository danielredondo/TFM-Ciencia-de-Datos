setwd("TFM/Analisis_preliminar/descarga_20200509/gdc_download_20200509_173000.089392/")
source("C:/Users/dredondo/Dropbox/Transporte_interno/Máster/Ciencia de Datos/TFM/Analisis_preliminar/01_preprocesamiento.R",
encoding = "UTF-8")
# ----- Carga de paquetes -----
library(BiocManager) # Para instalar KnowSeq
library(KnowSeq)     # Para trabajar con genes - instalado a partir de .tar.gz de SWAD
library(tictoc)      # Para medir tiempos con tic() y toc() a lo MATLAB
library(R.utils)     # Para gunzip (descompresión de .gz)
library(dplyr)       # Para select, filter, pipes, ...
library(beepr)       # Para avisar con beeps cuando acaba un proceso
library(caret)       # Para ml
library(e1071)       # Para svm
library(reshape)     # Para melt
library(gplots)      # Para heatmaps
# ----- Unificación de ficheros en formato matriz -----
tic("countsToMatrix")
countsInformation <- countsToMatrix("SamplesDataFrame.csv", extension = "counts")
toc()
# ----- La matriz de cuentas y las etiquetas se guardan -----
countsMatrix <- countsInformation$countsMatrix
labels <- countsInformation$labels
# ----- Se descargan los nombres de los genes -----
myAnnotation <- getGenesAnnotation(rownames(countsMatrix))
# ----- Cálculo de matriz de expresión de genes -----
tic("calculateGeneExpressionValues")
expressionMatrix <- calculateGeneExpressionValues(countsMatrix, myAnnotation, genesNames = TRUE)
toc()
# ----- Boxplots de la expresión para todos los genes -----
dataPlot(expressionMatrix, labels, mode = "boxplot", colours = c("blue", "red"), toPNG = TRUE)
dataPlot(expressionMatrix, labels, mode = "orderedBoxplot", colours = c("blue", "red"), toPNG = TRUE)
# ----- Sin controlar por el efecto batch -----
###
### DEGsInformation <- DEGsExtraction(expressionMatrix, as.factor(labels),
###                                   # Default parameters
###                                   lfc = 1.0, pvalue = 0.1)
###
# ----- Controlando por el efecto batch -----
tic("batchEffectRemoval")
svaMod <- batchEffectRemoval(expressionMatrix, as.factor(labels), method = "sva")
toc()
# ----- Extracción de DEG (Expresión Diferencial de Genes) -----
tic("DEGsExtraction")
DEGsInformation <- DEGsExtraction(expressionMatrix, as.factor(labels),
# Default parameters
lfc = 1.0, pvalue = 0.1,
# Ajuste por batchEffect
svaCorrection = TRUE, svaMod = svaMod)
toc()
# Número de genes extraídos
print(nrow(DEGsInformation$DEGsMatrix))
topTable <- DEGsInformation$Table
DEGsMatrix <- DEGsInformation$DEGsMatrix
head(topTable) # Si la primera columna es negativa, infrarepresentado
# positiva = gen sobreexpresado
# Se traspone la matriz
DEGsMatrixML <- t(DEGsMatrix)
# ----- Representación de DEG -----
# Boxplots para todas las muestras de los primeros genes
dataPlot(DEGsMatrix[1:11, ], labels, mode = "genesBoxplot", toPNG = TRUE)
# Mapa de calor para todas las muestras de los primeros genes
dataPlot(DEGsMatrix[1:11, ], labels, mode = "heatmap", toPNG = TRUE)
# ----- Partición entrenamiento-test -----
# Partición 75% / 25% con balanceo de clase
indices <- createDataPartition(SamplesDataFrame$Class, p = .75, list = FALSE)
particion <- list(training = DEGsMatrixML[indices, ], test = DEGsMatrixML[-indices, ])
# Conjuntos
particion.entrenamiento <- particion$training
particion.test <- particion$test
# Etiquetas
labels_train <- SamplesDataFrame$Class[indices]
labels_test  <- SamplesDataFrame$Class[-indices]
# Número de casos
# Train
table(labels_train)
# Test
table(labels_test)
# Verificar balanceo de clase en entrenamiento y test
# Train
labels_train %>% table %>% prop.table %>% round(3) * 100
# Test
labels_test %>% table %>% prop.table %>% round(3) * 100
# ----- Selección de características -----
# Método mRMR (mínima redundancia, máxima relevancia)
mrmrRanking <- featureSelection(particion.entrenamiento, labels_train, colnames(particion.entrenamiento),
mode = "mrmr")
# Método random forest
rfRanking <- featureSelection(particion.entrenamiento, labels_train, colnames(particion.entrenamiento),
mode = "rf")
# Método Disease association ranking (en base a scores obtenidos en la literatura)
daRanking <- featureSelection(particion.entrenamiento, labels_train, colnames(particion.entrenamiento),
mode = "da", disease = "pancreatic cancer")
# -----  Sobreescribir la función dataPlot con la nueva función que pinta líneas discontinuas -----
source("../../Funciones_actualizadas_KnowSeq/dataPlot.R")
# ----- Resultados de SVM con validación cruzada para cada método de selección de características -----
numero_folds <- 3
# mRMR
results_cv_svm_mrmr <- svm_CV(particion.entrenamiento, labels_train, names(mrmrRanking),
numFold = numero_folds)
results_cv_svm_mrmr$bestParameters
# random forest
results_cv_svm_rf <- svm_CV(particion.entrenamiento, labels_train, rfRanking,
numFold = numero_folds)
results_cv_svm_rf$bestParameters
# disease association
results_cv_svm_da <- svm_CV(particion.entrenamiento, labels_train, names(daRanking),
numFold = numero_folds)
results_cv_svm_da$bestParameters
# ----- Resultados de SVM gráficamente -----
# Plotting the accuracy of all the folds evaluated in the CV process
#png(filename = "MRMR.png")
dataPlot(results_cv_svm_mrmr$accMatrix[, 1:11], mode = "classResults",
main = "mRMR - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
#dev.off()
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_svm_rf$accMatrix[, 1:9], colours = rainbow(numero_folds), mode = "classResults",
main = "rf - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_svm_da$accMatrix[, 1:9], colours = rainbow(numero_folds), mode = "classResults",
main = "da - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# --- Mejor método en CV basado en precisión ---
genes_a_usar <- c(1:11)
for(i in 1:length(genes_a_usar)){
precisiones <- c(mean(results_cv_svm_mrmr$accMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_rf$accMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_da$accMatrix[, genes_a_usar[i]]))
names(precisiones) <- c("MRMR", "RF", "DA")
cat(paste("Precisiones para", genes_a_usar[i], "gen(es):\n"))
print(round(100*precisiones, 1))
cat("-----------------------------\n")
}
# --- Mejor método en CV basado en especificidad ---
genes_a_usar <- c(1:11)
for(i in 1:length(genes_a_usar)){
spec <- c(mean(results_cv_svm_mrmr$specMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_rf$specMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_da$specMatrix[, genes_a_usar[i]]))
names(spec) <- c("MRMR", "RF", "DA")
cat(paste("Especificidad para", genes_a_usar[i], "gen(es):\n"))
print(round(100*spec, 1))
cat("-----------------------------\n")
}
# ----- Preprocesamiento de test para aplicar SVM -----
#save.image(file = "entorno.RData")
#load("entorno.RData")
# ----- Resultados de SVM train-test -----
# mRMR
results_svm_mrmr <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(mrmrRanking),
bestParameters = results_cv_svm_mrmr$bestParameters)
# random forest
results_svm_rf <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, rfRanking,
bestParameters = results_cv_svm_rf$bestParameters)
# disease association
results_svm_da <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(daRanking),
bestParameters = results_cv_svm_da$bestParameters)
# ----- Matrices de confusión -----
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[[10]]$table
beep()
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[[4]]$table
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[[3]]$table
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[[2]]$table
# mRMR
results_svm_mrmr <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(mrmrRanking),
bestParameters = results_cv_svm_mrmr$bestParameters)
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[10]$table
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[10]$table
# mRMR
results_svm_mrmr <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(mrmrRanking),
bestParameters = results_cv_svm_mrmr$bestParameters)
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[10]$table
# ----- Ruta de trabajo -----
set.seed(1991)
# Windows
setwd("C:/Users/dredondo/Dropbox/Transporte_interno/Máster/Ciencia de Datos/")
# Mac
#setwd("/Users/daniel/Dropbox/Transporte_interno/Máster/Ciencia de Dato/")
setwd("TFM/Analisis_preliminar/descarga_20200509/gdc_download_20200509_173000.089392/")
source("C:/Users/dredondo/Dropbox/Transporte_interno/Máster/Ciencia de Datos/TFM/Analisis_preliminar/01_preprocesamiento.R",
encoding = "UTF-8")
# ----- Carga de paquetes -----
library(BiocManager) # Para instalar KnowSeq
library(KnowSeq)     # Para trabajar con genes - instalado a partir de .tar.gz de SWAD
library(tictoc)      # Para medir tiempos con tic() y toc() a lo MATLAB
library(R.utils)     # Para gunzip (descompresión de .gz)
library(dplyr)       # Para select, filter, pipes, ...
library(beepr)       # Para avisar con beeps cuando acaba un proceso
library(caret)       # Para ml
library(e1071)       # Para svm
library(reshape)     # Para melt
library(gplots)      # Para heatmaps
# ----- Unificación de ficheros en formato matriz -----
tic("countsToMatrix")
countsInformation <- countsToMatrix("SamplesDataFrame.csv", extension = "counts")
toc()
# ----- La matriz de cuentas y las etiquetas se guardan -----
countsMatrix <- countsInformation$countsMatrix
labels <- countsInformation$labels
# ----- Se descargan los nombres de los genes -----
myAnnotation <- getGenesAnnotation(rownames(countsMatrix))
# ----- Cálculo de matriz de expresión de genes -----
tic("calculateGeneExpressionValues")
expressionMatrix <- calculateGeneExpressionValues(countsMatrix, myAnnotation, genesNames = TRUE)
toc()
# ----- Boxplots de la expresión para todos los genes -----
dataPlot(expressionMatrix, labels, mode = "boxplot", colours = c("blue", "red"), toPNG = TRUE)
dataPlot(expressionMatrix, labels, mode = "orderedBoxplot", colours = c("blue", "red"), toPNG = TRUE)
# ----- Sin controlar por el efecto batch -----
###
### DEGsInformation <- DEGsExtraction(expressionMatrix, as.factor(labels),
###                                   # Default parameters
###                                   lfc = 1.0, pvalue = 0.1)
###
# ----- Controlando por el efecto batch -----
tic("batchEffectRemoval")
svaMod <- batchEffectRemoval(expressionMatrix, as.factor(labels), method = "sva")
toc()
# ----- Extracción de DEG (Expresión Diferencial de Genes) -----
tic("DEGsExtraction")
DEGsInformation <- DEGsExtraction(expressionMatrix, as.factor(labels),
# Default parameters
lfc = 1.0, pvalue = 0.1,
# Ajuste por batchEffect
svaCorrection = TRUE, svaMod = svaMod)
toc()
# Número de genes extraídos
print(nrow(DEGsInformation$DEGsMatrix))
topTable <- DEGsInformation$Table
DEGsMatrix <- DEGsInformation$DEGsMatrix
head(topTable) # Si la primera columna es negativa, infrarepresentado
# positiva = gen sobreexpresado
# Se traspone la matriz
DEGsMatrixML <- t(DEGsMatrix)
# ----- Representación de DEG -----
# Boxplots para todas las muestras de los primeros genes
dataPlot(DEGsMatrix[1:11, ], labels, mode = "genesBoxplot", toPNG = TRUE)
# Mapa de calor para todas las muestras de los primeros genes
dataPlot(DEGsMatrix[1:11, ], labels, mode = "heatmap", toPNG = TRUE)
# ----- Partición entrenamiento-test -----
# Partición 75% / 25% con balanceo de clase
indices <- createDataPartition(SamplesDataFrame$Class, p = .75, list = FALSE)
particion <- list(training = DEGsMatrixML[indices, ], test = DEGsMatrixML[-indices, ])
# Conjuntos
particion.entrenamiento <- particion$training
particion.test <- particion$test
# Etiquetas
labels_train <- SamplesDataFrame$Class[indices]
labels_test  <- SamplesDataFrame$Class[-indices]
# Número de casos
# Train
table(labels_train)
# Test
table(labels_test)
# Verificar balanceo de clase en entrenamiento y test
# Train
labels_train %>% table %>% prop.table %>% round(3) * 100
# Test
labels_test %>% table %>% prop.table %>% round(3) * 100
# ----- Selección de características -----
# Método mRMR (mínima redundancia, máxima relevancia)
mrmrRanking <- featureSelection(particion.entrenamiento, labels_train, colnames(particion.entrenamiento),
mode = "mrmr")
# Método random forest
rfRanking <- featureSelection(particion.entrenamiento, labels_train, colnames(particion.entrenamiento),
mode = "rf")
# Método Disease association ranking (en base a scores obtenidos en la literatura)
daRanking <- featureSelection(particion.entrenamiento, labels_train, colnames(particion.entrenamiento),
mode = "da", disease = "pancreatic cancer")
# -----  Sobreescribir la función dataPlot con la nueva función que pinta líneas discontinuas -----
source("../../Funciones_actualizadas_KnowSeq/dataPlot.R")
# ----- Resultados de SVM con validación cruzada para cada método de selección de características -----
numero_folds <- 3
# mRMR
results_cv_svm_mrmr <- svm_CV(particion.entrenamiento, labels_train, names(mrmrRanking),
numFold = numero_folds)
results_cv_svm_mrmr$bestParameters
# random forest
results_cv_svm_rf <- svm_CV(particion.entrenamiento, labels_train, rfRanking,
numFold = numero_folds)
results_cv_svm_rf$bestParameters
# disease association
results_cv_svm_da <- svm_CV(particion.entrenamiento, labels_train, names(daRanking),
numFold = numero_folds)
results_cv_svm_da$bestParameters
# ----- Resultados de SVM gráficamente -----
# Plotting the accuracy of all the folds evaluated in the CV process
#png(filename = "MRMR.png")
dataPlot(results_cv_svm_mrmr$accMatrix[, 1:11], mode = "classResults",
main = "mRMR - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
#dev.off()
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_svm_rf$accMatrix[, 1:9], colours = rainbow(numero_folds), mode = "classResults",
main = "rf - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_svm_da$accMatrix[, 1:9], colours = rainbow(numero_folds), mode = "classResults",
main = "da - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# --- Mejor método en CV basado en precisión ---
genes_a_usar <- c(1:5, 10)
for(i in 1:length(genes_a_usar)){
precisiones <- c(mean(results_cv_svm_mrmr$accMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_rf$accMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_da$accMatrix[, genes_a_usar[i]]))
names(precisiones) <- c("MRMR", "RF", "DA")
cat(paste("Precisiones para", genes_a_usar[i], "gen(es):\n"))
print(round(100*precisiones, 1))
cat("-----------------------------\n")
}
# --- Mejor método en CV basado en especificidad ---
genes_a_usar <- c(1:11)
for(i in 1:length(genes_a_usar)){
spec <- c(mean(results_cv_svm_mrmr$specMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_rf$specMatrix[, genes_a_usar[i]]),
mean(results_cv_svm_da$specMatrix[, genes_a_usar[i]]))
names(spec) <- c("MRMR", "RF", "DA")
cat(paste("Especificidad para", genes_a_usar[i], "gen(es):\n"))
print(round(100*spec, 1))
cat("-----------------------------\n")
}
# ----- Preprocesamiento de test para aplicar SVM -----
#save.image(file = "entorno.RData")
#load("entorno.RData")
# ----- Resultados de SVM train-test -----
# mRMR
results_svm_mrmr <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(mrmrRanking),
bestParameters = results_cv_svm_mrmr$bestParameters)
# random forest
results_svm_rf <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, rfRanking,
bestParameters = results_cv_svm_rf$bestParameters)
# disease association
results_svm_da <- svm_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(daRanking),
bestParameters = results_cv_svm_da$bestParameters)
# ----- Matrices de confusión -----
# Matriz de confusión mejor clasificador
results_svm_mrmr$cfMats[10]$table
# Gráficamente
dataPlot(results_svm_mrmr$cfMats[[10]]$table, labels_test,
mode = "confusionMatrix")
dataPlot(results_svm_mrmr$cfMats[[10]]$table, labels_test,
mode = "confusionMatrix")
# mRMR
results_cv_svm_mrmr <- knn_CV(particion.entrenamiento, labels_train, names(mrmrRanking),
numFold = numero_folds)
results_cv_svm_mrmr$bestParameters
results_cv_svm_mrmr$bestK
# ----- Análogo para kNN -----
numero_folds <- 3
# mRMR
results_cv_knn_mrmr <- knn_CV(particion.entrenamiento, labels_train, names(mrmrRanking),
numFold = numero_folds)
results_cv_knn_mrmr$bestK
# random forest
results_cv_knn_rf <- knn_CV(particion.entrenamiento, labels_train, rfRanking,
numFold = numero_folds)
results_cv_knn_rf$bestK
# disease association
results_cv_knn_da <- knn_CV(particion.entrenamiento, labels_train, names(daRanking),
numFold = numero_folds)
results_cv_knn_da$bestK
# Plotting the accuracy of all the folds evaluated in the CV process
#png(filename = "MRMR.png")
dataPlot(results_cv_knn_mrmr$accMatrix[, 1:11], mode = "classResults",
main = "mRMR - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
dev.off()
dev.off()
# Plotting the accuracy of all the folds evaluated in the CV process
#png(filename = "MRMR.png")
dataPlot(results_cv_knn_mrmr$accMatrix[, 1:11], mode = "classResults",
main = "mRMR - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_knn_da$accMatrix[, 1:9], colours = rainbow(numero_folds), mode = "classResults",
main = "da - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_knn_rf$accMatrix[, 1:9], colours = rainbow(numero_folds), mode = "classResults",
main = "rf - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_svm_rf$accMatrix[, 1:11], colours = rainbow(numero_folds), mode = "classResults",
main = "rf - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_svm_da$accMatrix[, 1:11], colours = rainbow(numero_folds), mode = "classResults",
main = "da - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_knn_rf$accMatrix[, 1:11], colours = rainbow(numero_folds), mode = "classResults",
main = "rf - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# Plotting the accuracy of all the folds evaluated in the CV process
dataPlot(results_cv_knn_da$accMatrix[, 1:11], colours = rainbow(numero_folds), mode = "classResults",
main = "da - Accuracy for each fold", xlab = "Genes", ylab = "Accuracy", toPNG = TRUE)
# --- Mejor método en CV basado en precisión ---
genes_a_usar <- c(1:5, 10)
for(i in 1:length(genes_a_usar)){
precisiones <- c(mean(results_cv_knn_mrmr$accMatrix[, genes_a_usar[i]]),
mean(results_cv_knn_rf$accMatrix[, genes_a_usar[i]]),
mean(results_cv_knn_da$accMatrix[, genes_a_usar[i]]))
names(precisiones) <- c("MRMR", "RF", "DA")
cat(paste("Precisiones para", genes_a_usar[i], "gen(es):\n"))
print(round(100*precisiones, 1))
cat("-----------------------------\n")
}
results_cv_knn_mrmr$accMatrix
# --- Mejor método en CV basado en precisión ---
genes_a_usar <- c(1:5, 10)
for(i in 1:length(genes_a_usar)){
precisiones <- c(mean(results_cv_knn_mrmr$accMatrix[, genes_a_usar[i]]),
mean(results_cv_knn_rf$accMatrix[, genes_a_usar[i]]),
mean(results_cv_knn_da$accMatrix[, genes_a_usar[i]]))
names(precisiones) <- c("MRMR", "RF", "DA")
cat(paste("Precisiones para", genes_a_usar[i], "gen(es):\n"))
print(round(100*precisiones, 1))
cat("-----------------------------\n")
}
results_cv_knn_mrmr
# --- Mejor método en CV basado en especificidad ---
genes_a_usar <- c(1:5, 10)
for(i in 1:length(genes_a_usar)){
spec <- c(mean(results_cv_knn_mrmr$specMatrix[, genes_a_usar[i]]),
mean(results_cv_knn_rf$specMatrix[, genes_a_usar[i]]),
mean(results_cv_knn_da$specMatrix[, genes_a_usar[i]]))
names(spec) <- c("MRMR", "RF", "DA")
cat(paste("Especificidad para", genes_a_usar[i], "gen(es):\n"))
print(round(100*spec, 1))
cat("-----------------------------\n")
}
# mRMR
results_knn_mrmr <- knn_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(mrmrRanking),
bestParameters = results_cv_knn_mrmr$bestK)
# random forest
results_knn_rf <- knn_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, rfRanking,
bestParameters = results_cv_knn_rf$bestK)
# disease association
results_knn_da <- knn_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(daRanking),
bestParameters = results_cv_knn_da$bestK)
# mRMR
results_knn_mrmr <- knn_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(mrmrRanking),
bestK = results_cv_knn_mrmr$bestK)
# random forest
results_knn_rf <- knn_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, rfRanking,
bestK = results_cv_knn_rf$bestK)
# disease association
results_knn_da <- knn_test(train = particion.entrenamiento, labels_train,
test = particion.test, labels_test, names(daRanking),
bestK = results_cv_knn_da$bestK)
# Matriz de confusión mejor clasificador
results_knn_mrmr$cfMats[10]$table
results_knn_mrmr
# Matriz de confusión mejor clasificador
results_knn_mrmr$cfMats[[10]]$table
# Gráficamente
dataPlot(results_knn_mrmr$cfMats[[10]]$table, labels_test,
mode = "confusionMatrix")
# Matriz de confusión mejor clasificador
results_knn_mrmr$cfMats[[1]]$table
# Gráficamente
dataPlot(results_knn_mrmr$cfMats[[1]]$table, labels_test,
mode = "confusionMatrix")
# Se recuperan las 20 enfermedades más importantes vinculadas
# Se usan los 4 genes más relevantes usando mRMR, el mejor método encontrado anteriormente
diseases <- DEGsToDiseases(mrmrRanking[1:10], getEvidences = TRUE, size = 20)
diseases
mrmrRanking
names(sort(mrmrRanking))
# Se recuperan las 20 enfermedades más importantes vinculadas
# Se usan los 4 genes más relevantes usando mRMR, el mejor método encontrado anteriormente
diseases <- DEGsToDiseases(names(sort(mrmrRanking))[1:10], getEvidences = TRUE, size = 20)
diseases
# Extracción de todas las enfermedades relacionadas con los 10 genes
enfermedades <- c()
for(i in 1:10){
# Se extraen las enfermedades relacionadas
enfermedades <- c(enfermedades, diseases[[i]]$summary[, 1])
# Se eliminan duplicados
enfermedades <- unique(enfermedades)
}
diseases
length(diseases)
# Se recuperan las 20 enfermedades más importantes vinculadas
# Se usan los 10 genes más relevantes usando mRMR, el mejor método encontrado anteriormente
diseases <- DEGsToDiseases(names(sort(mrmrRanking))[1:10], getEvidences = TRUE, size = 20)
# Extracción de todas las enfermedades relacionadas con los 10 genes
enfermedades <- c()
for(i in 1:length(diseases)){
# Se extraen las enfermedades relacionadas
enfermedades <- c(enfermedades, diseases[[i]]$summary[, 1])
# Se eliminan duplicados
enfermedades <- unique(enfermedades)
}
enfermedades
# Buscar cáncer
enfermedades[grep(pattern = "cancer", x = enfermedades)]
enfermedades[grep(pattern = "panc", x = enfermedades)]
enfermedades[grep(pattern = "neopl", x = enfermedades)]
# Buscar cáncer
enfermedades[grep(pattern = "cancer", x = enfermedades)]
# Buscar cáncer
enfermedades[grep(pattern = "cancer", x = enfermedades)]
enfermedades[grep(pattern = "neopl", x = enfermedades)]
